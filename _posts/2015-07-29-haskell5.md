---
layout: post
title: <++>
tags: <++>
year: 2015
month: 07
day: 29
published: <+false+>
summary: <++>
---

```haskell
-- Problem 35:
primefactors :: Integer -> [Integer]
primefactors n = primefactors' n 2
    where
    primefactors' 1 _ = []
    primefactors' n f | n `mod` f == 0 = f : primefactors' (n `div` f) f
                      | otherwise = primefactors' n (f + 1)

-- Problem 36:
prime_factors_group :: Integer -> [(Integer, Int)]
prime_factors_group = map encode . group . primefactors
    where encode xs = (head xs, length xs)

-- Problem 37:
phi :: Integer -> Integer
phi n = foldl (*) 1 [(p - 1) * p ^ (m - 1) | (p, m) <- prime_factors_group n]

-- Problem 39:
primesR a b = takeWhile (<= b) $ dropWhile (< a) primes

data Wheel = Wheel Integer [Integer]

roll (Wheel n rs) = [n*k+r | k <- [0..], r <- rs]

w0 = Wheel 1 [1]

nextSize (Wheel n rs) p =
  Wheel (p*n) [r2 | k <- [0..(p-1)], r <- rs,
                    let r2 = n*k+r, r2 `mod` p /= 0]

mkWheel ds = foldl nextSize w0 ds

primes = small ++ large
    where
    1:p:candidates = roll $ mkWheel small
    small          = [2,3,5,7]
    large          = p : filter isPrime candidates
    isPrime n      = all (not . divides n)
                       $ takeWhile (\p -> p*p <= n) large
    divides n p    = n `mod` p == 0
```
