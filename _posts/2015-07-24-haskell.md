---
layout: post
title: 99 problems in Haskell, 1-10
tags: 99-problems haskell
year: 2015
month: 07
day: 24
published: true
summary: Cultural learnings of 99 problems for Make Benefit Glorious Language of Haskell
---
To celebrate trying to learn Haskell for a few weeks now, I figured I'd do a quick rundown
of [99 Haskell Problems](https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems), as
I try to solve them[^1].

I'll try and post my 'solutions' as soon as it satisfies the problem definition; in that
sense, I expect they'll appear very crude to Haskell veterans but hey, when was that ever
a showstopper? Here we go with problems 1-10:

```haskell

-- Find the last element of a list:
mylast :: [a] -> a
mylast [] = error "empty list"
mylast [x] = x
mylast (_:xs) = mylast xs

-- Find the last but one element of a list:
lastbutone :: [a] -> a
lastbutone [] = error "empty list"
lastbutone [x] = error "single element list"
lastbutone [x, _] = x
lastbutone (_:xs) = lastbutone xs

-- Find the k'th element of a list. The first element in the list is number 1:
elementAt :: [a] -> Int -> a
elementAt xs n = last ( take n xs)

-- Find the number of elements of a list:
mylength :: [a] -> Int
mylength [] = 0
mylength (_:xs) = 1 + mylength xs

-- Reverse a list:
myreverse :: [a] -> [a]
myreverse [] = []
myreverse xs = myreverse (tail xs) ++ [head xs]

-- Find out whether a list is a palindrome:
isPalindrome :: (Eq a) => [a] -> Bool
isPalindrome [] = True
isPalindrome [_] = True
isPalindrome xs = (head xs) == (last xs) && (isPalindrome (init (tail xs)))

-- Flatten a nested list structure:
data NestedList a = Elem a | List [NestedList a]

myflatten :: NestedList a -> [a]
myflatten (Elem x) = [x]
myflatten (List []) = []
myflatten (List (x:xs)) = myflatten x ++ myflatten (List xs)

-- Eliminate consecutive duplicates of list elements:
compress :: (Eq a) => [a] -> [a]
compress (x:xs@(y:_))
        | x == y    = compress xs
        | otherwise = x : compress xs
compress xs = xs

-- Pack consecutive duplicates of list elements into sublists. If a list contains repeated
-- elements they should be placed in separate sublists:
pack :: (Eq a) => [a] -> [[a]]
pack [] = []
pack (x:xs) = let (first, rest) = span (==x) xs
              in (x:first) : pack rest

-- Run-length encoding of a list:
encode :: (Eq a) => [a] -> [(Int, a)]
encode xs = map (\x -> (length x, head x)) (group xs)
```

[^1]: Â± a month
